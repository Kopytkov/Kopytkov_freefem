int labelOut = 1;  /* label for outer circle*/
int labelLeftInnerEllipse = 2; /* label for left inner ellipse */
int labelRightInnerEllipse = 3; /* label for right inner ellipse */
int labelInnerSmile = 4; /* label for inner Smile*/

/* coordinates of circle */
real xMin = 1.0;
real xMax = 11.0;
real yMin = 1.0;
real yMax = 8.0;
real xCenter = (xMin + xMax) / 2.0;
real yCenter = (yMin + yMax) / 2.0;

real ROut = 12.0; /*radius of GammaOut*/

border GammaOut(t = 0.0, 2.0*pi){
    x = xCenter + ROut*cos(t);
    y = yCenter + ROut*sin(t);
    label = labelOut;
}

/*param of inner Ellipses*/
real aEll = 1.3;
real bEll = 0.7;
real xInLE = xMin;
real xInRE = xMax;
real ydist = 2.0; /*y-center offset*/
real ellDisp = (yMax + yMin)/2.0 + ydist; /*Elliptical displacement*/

border innerEllipse1(t= 0.0, 2*pi){ 
    x = xInLE +  aEll*cos(t); 
    y = bEll*sin(t) + ellDisp;
    label = labelLeftInnerEllipse ;
}

border innerEllipse2(t= 0.0, 2*pi){ 
    x = xInRE + aEll*cos(t); 
    y = bEll*sin(t) + ellDisp;
    label = labelRightInnerEllipse ;
}

/*param of Smile*/
real aSmile = 2.2;
real bSmile = 0.8;
real xSmile = xCenter;
real SmileDisp = (yMax + yMin)/2.0 - ydist; /*Elliptical displacement*/
real deform = 2.0; /*param of deform*/

/* Func for create a Smile */
func real deformation(real y) {
    return y * (1 - deform * y); /* “squeeze” the top */
}

/* Top part of Smile */
border upperEllipse(t = 0, pi) {
    x = xSmile + aSmile * cos(t);
    y = deformation(bSmile * sin(t)) + SmileDisp;
    label = labelInnerSmile;
}

/* Bottom part of Smile (for closing the loop) */
border lowerEllipse(t = pi, 0) {
    x = xSmile + aSmile * cos(t);
    y = -bSmile * sin(t) + SmileDisp;
    label = labelInnerSmile;
}

int NOut = 50;
int NIn = 20;

mesh Th1 = buildmesh(GammaOut(NOut)
    + innerEllipse1(-NIn) + innerEllipse2(-NIn)
    + upperEllipse(-NIn) + lowerEllipse(-NIn));
plot(Th1, wait = true, dim=2);

/*define u, f and boundary conditions*/
func uExactFunc = x*sin(pi * y) + y*sin(pi * x);
func f = pi^2 * uExactFunc;

/* Neumann boundary condition */
func NeumannBC = (sin(pi*y) + pi*y*cos(pi*x))* N.x + (pi*x*cos(pi*y) + sin(pi*x))* N.y;

/* Dirichlet boundary condition */
func uout = uExactFunc;

/* Define finite element space */
fespace Vh1(Th1, P1);
Vh1 u, v;

/* Variational formulation */
solve Poisson (u, v) =
    int2d(Th1)(dx(u) * dx(v) + dy(u) * dy(v)) /* Laplace operator */
    - int2d(Th1)(f * v) /* Right-hand side */
    - int1d(Th1, labelLeftInnerEllipse )(NeumannBC * v) /* Neumann condition on first inner boundary */
    - int1d(Th1, labelRightInnerEllipse )(NeumannBC * v) /* Neumann condition on second inner boundary */
    - int1d(Th1, labelInnerSmile)(NeumannBC * v) /* Neumann condition on smile */
    + on(labelOut, u = uout); /* Dirichlet condition on outer boundary */


int countVert = 0; /*the number of vertices of selected label*/
int label = 1; /*selectd label (outer boundary)*/
real [int] coordOfLabelX(NOut);
real [int] coordOfLabelY(NOut);
real [int] centerOfLabelX(NOut);
real [int] centerOfLabelY(NOut);
for (int it = 0; it < Th1.nv; it++){
    if (Th1(it).label == label){
        cout << "Vertex # " << countVert << "  : (x, y) = " << Th1(it).x << ", " << Th1(it).y <<endl;
        coordOfLabelX[countVert] = Th1(it).x;
        coordOfLabelY[countVert] = Th1(it).y;
        countVert++;
    }
}
cout << "Number of vertex label 1 = " << countVert << endl;

/*create and work with file */
{
    /*create a file */
    ofstream filename("UCenterOfBoundaryEdges.txt");
    filename << "label = " << label << endl;

    /*Boundary Edges center coordinates and u(x, y)*/
    centerOfLabelX[0] = (coordOfLabelX[0] + coordOfLabelX[1]) / 2.0;
    centerOfLabelY[0] = (coordOfLabelY[0] + coordOfLabelY[1]) / 2.0;

    filename << "Center of Boundary Edge # " << 0 
    << "  : (x, y) = " << centerOfLabelX[0] << ", " << centerOfLabelY[0] << ";" << endl 
    << "u(x, y) = " << u(centerOfLabelX[0], centerOfLabelY[0]) << endl;

    centerOfLabelX[countVert - 1] = (coordOfLabelX[countVert - 1] + coordOfLabelX[countVert - 2]) / 2.0;
    centerOfLabelY[countVert - 1] = (coordOfLabelY[countVert - 1] + coordOfLabelY[countVert - 2]) / 2.0;

    for (int i = 1; i < NOut - 1; i++){
        /*calculating the coordinates of the edge center*/
        centerOfLabelX[i] = (coordOfLabelX[i-1] + coordOfLabelX[i+1]) / 2.0;
        centerOfLabelY[i] = (coordOfLabelY[i-1] + coordOfLabelY[i+1]) / 2.0;
        filename << "Center of Boundary Edge # " << i 
        << "  : (x, y) = " << centerOfLabelX[i] << ", " << centerOfLabelY[i] << ";" << endl
        << "u(x, y) = " << u(centerOfLabelX[i], centerOfLabelY[i]) << endl;
    }

    filename << "Center of Boundary Edge # " << (countVert - 1) 
    << "  : (x, y) = " << centerOfLabelX[countVert - 1] << ", " << centerOfLabelY[countVert - 1]<< ";" << endl
    << "u(x, y) = " << u(centerOfLabelX[countVert - 1], centerOfLabelY[countVert - 1]) << endl;
}